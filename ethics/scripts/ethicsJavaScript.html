<script>

// overall function to clean up div classes after any transitions either on initial pt 1 guidance or later quiz pt 2 guidance

function removeClassOnTransitionEnd(element, ...classNames) {
  const handleTransitionEnd = (e) => {
    if (e.propertyName === 'transform') {
      element.classList.remove(...classNames);
      element.removeEventListener('transitionend', handleTransitionEnd);
    }
  };
  element.addEventListener('transitionend', handleTransitionEnd);
}

// overall function for resetting answers and any buttons that are showing if user goes from quiz to guidance info

function resetAnswersButtons(classAnswers, classButtons) {
  const answers = document.querySelectorAll(classAnswers);
  answers.forEach(answer => answer.reset());
  answers.forEach(answer => answer.dataset.answered = "false");

  const buttons = document.querySelectorAll(classButtons); // hide all next buttons again
  buttons.forEach(button => button.style.display = "none");
};



// script pt 1 for handling which guidance material to show

const form = document.getElementById("whichRoute");  // constant to identify the form DOM


let currentDiv = null;
let outgoingDiv = null;

// last two variables necessary for animation to run smoothly


// add event listenter to form so that on change the selected guidance div shows up
// and comes in from the right while the previous one goes out to the left and fades away

form.addEventListener('change', (event) => {

  const selected = event.target.value;  // use input value then concat with Guidance to capture the chosen Div
  const selectedDiv = document.getElementById(selected + 'Guidance');


  const guides = document.querySelectorAll('.guidance');
  guides.forEach(guide => guide.classList.remove('show', 'hide-left')); // clean up any CSS transition labels that may be present from quiz questions

  // reset all quiz class divs & all quiz answers if any previous input
  // --> likely want to adjust in future to allow answers to stay on change, but not on page refresh
  const quizzes = document.querySelectorAll('.quiz');
  quizzes.forEach(quiz => quiz.classList.remove('show', 'hide-left')); // clean up any CSS transition labels that may be present from quiz questions
  resetAnswersButtons('.answers', '.manual-next') // reset quiz answers and buttons

 if (currentDiv === selectedDiv) {
    return; // no change has occurred, nothing happens
 }



  // If changed, show the div that matches the selected value

 if (currentDiv) {  // If currentDiv is not null (i.e. there hasn't been a div selected yet) need to clean up CSS so that div can disappear as desired



  outgoingDiv = currentDiv; // set currentDiv to outgoingDiv and the run following on outgoingDiv so that it disappears and stays away during all other steps
                            // if not done this way will get overlaps with calling same div as selectedDiv and will also run into problems with hide-left not
                            // being properly removed


    // Slide out outgoingDiv to the left
   outgoingDiv.classList.remove('show');
   outgoingDiv.classList.add('hide-left');

    // When the slide-out finishes, clean up by removing hide-left (ensures that upon later changes div will come in from the right not the left)
  removeClassOnTransitionEnd(outgoingDiv, 'hide-left');

 };




      // Prepare the new guidance to come from the right (remove any previous show or hide-left transitions)

   selectedDiv.classList.remove('hide-left', 'show');

      // Force browser to reflow so transition triggers properly
   void selectedDiv.offsetWidth;

      // Then trigger its slide in
   selectedDiv.classList.add('show');



      if (selectedDiv.id === 'quizGuidance') { // when selectedDiv is the quiz then also show the first question of the quiz (otherwise quiz won't reset when reselecting this div)
       let quest1 = document.getElementById('quest1')
       quest1.classList.add('show');
      }



      // Update reference
   currentDiv = selectedDiv;



 });

// script pt 2 handling the quiz

const historyStack = []; //used to help with navigation of divs in quiz

const q1 = document.getElementById("answersQ1");
const q2 = document.getElementById("answersQ2");
const q3 = document.getElementById("answersQ3");
const q4 = document.getElementById("answersQ4");
const q5 = document.getElementById("answersQ5");
const q6 = document.getElementById("answersQ6");
const q7 = document.getElementById("answersQ7");
const q8 = document.getElementById("answersQ8");

const btn1_2 = document.getElementById("btn1_2");
const btn2_3 = document.getElementById("btn2_3");
const btn3_4 = document.getElementById("btn3_4");
const btn4_5 = document.getElementById("btn4_5");
const btn5_6 = document.getElementById("btn5_6");
const btn6_7 = document.getElementById("btn6_7");
const btn7_8 = document.getElementById("btn7_8");
const btn8_end = document.getElementById("btn8_end");


const btn2_1 = document.getElementById("btn2_1");
const btn3_2 = document.getElementById("btn3_2");
const btn4_3 = document.getElementById("btn4_3");
const btn5_4 = document.getElementById("btn5_4");
const btn6_5 = document.getElementById("btn6_5");
const btn7_6 = document.getElementById("btn7_6");
const btn8_7 = document.getElementById("btn8_7");

// create quiz map for when questions simply go to next default questions

const quizMap = {
    'quest1': { next: 'quest2', form: 'answersQ1' },
    'quest2': { next: 'quest3', form: 'answersQ2' },
    'quest3': { next: 'quest4', form: 'answersQ3' },
    'quest4': { next: 'quest5', form: 'answersQ4' },
    'quest5': { next: 'quest6', form: 'answersQ5' },
    'quest6': { next: 'quest7', form: 'answersQ6' },
    'quest7': { next: 'quest8', form: 'answersQ7' },
    'quest8': { next: 'suppB', form: 'answersQ8' } // default to suppB block for next if no other routing applied
};


// function to obtain selected value of a given formId even when no change has been made

function getSelectedValue(formId) {
    const selected = document.querySelector(`#${formId} input[type="radio"]:checked`);
    return selected ? selected.value : null;
}



// create function to have user go to next question if chosen answer forces them to move forward in quiz

function nextDiv(currentId, nextId, recordHistory = true) {
  let currentQ = document.getElementById(currentId)
  let nextQ = document.getElementById(nextId)


  // Slide out currentQ to the left
   currentQ.classList.remove('show');
   currentQ.classList.add('hide-left');

   // This allows it to reset its transform: translateX back to 100%
    // and wait off-screen properly for the next time it's needed.
    removeClassOnTransitionEnd(currentQ, 'hide-left', 'show');

      // Prepare the new guidance to come from the right (remove any previous show or hide-left transitions)

   nextQ.classList.remove('hide-left');

      // Force browser to reflow so transition triggers properly
   void nextQ.offsetWidth;

      // Then trigger its slide in
   nextQ.classList.add('show');

   // Record navigation history (defaults to true but can set to false if we don't want to record history)
   if (recordHistory) {
    if (historyStack.length === 0) {
      historyStack.push(currentId);
    }
      const lastId = historyStack[historyStack.length - 1];
      if (lastId !== nextId) {
       historyStack.push(nextId);
      }
   }


};

// create functions that allow the Next button to appear only if user is on a question that has already been answered
// and they need the Next button to advance (happens if they used the Back button in the quiz to go back)

// create function for auto-navigation when question is answered for the first time
// function to toggle the next button to showing if question already has an answer

function toggleNextIfAnswered(questionId, formId) {
  const form = document.getElementById(formId);
  const button = document.querySelector(`#${questionId} .manual-next`);

  if (form.dataset.answered === "true") {
    setTimeout(() => {
    button.style.display = "inline-block";
    }, 500); // use setTimeout to delay appearance of next button
  } else {
    button.style.display = "none";
  }
}

function handleQuizChange(currentId, nextId, formId) {
  const form = document.getElementById(formId);
  const alreadyAnswered = form.dataset.answered === "true"; // data-answered attribute is set to false in html on load

  if (!alreadyAnswered) {
    form.dataset.answered = "true";
    nextDiv(currentId, nextId);
  } else {
    nextDiv(currentId, nextId);
  }


  // Show/hide button depending on whether weâ€™ve answered
  toggleNextIfAnswered(currentId, formId);
}


// function to calculate overall answers for quests4-8: identify if any of these are answered as yes, as well as tally total no's and unsures.

function getTally() {
  const qIds = ['answersQ4', 'answersQ5', 'answersQ6', 'answersQ7', 'answersQ8'];

  let tally = {
    no: 0,
    unsure: 0,
    hasYes: false
  };

  qIds.forEach(id => {
    const val = getSelectedValue(id);
    if (val === 'yes') tally.hasYes = true;
    if (val === 'no') tally.no++;
    if (val === 'unsure') tally.unsure++;
  });

  return tally;

}

// create function for conditionals depending on which question we are at to determine routing


function navigateQuiz(currentId, isAutoAdvance = true) {
    const config = quizMap[currentId];
    const currentAnswer = getSelectedValue(config.form);
    const q2Answer = getSelectedValue("answersQ2");
    const q3Answer = getSelectedValue("answersQ3");
    const q4Answer = getSelectedValue("answersQ4");
    const q5Answer = getSelectedValue("answersQ5");
    const q6Answer = getSelectedValue("answersQ6");
    const q7Answer = getSelectedValue("answersQ7");
    const q8Answer = getSelectedValue("answersQ8");
    let destination = config.next;

    // 1. Determine destination based on current question and routing rules
    //Overall results after quiz completion:
//  -> if q1 is no, go immediately to definitely VCWE, but with info about studies without active participants
//  -> if q1 is unsure, go straight to Support A (Guidance on figuring out study more first)
//  -> if q2 is yes AND any of q4-8 are yes, go to definitely WMO
//  -> if q3 is yes, go immediately to definitely WMO
//  -> if q3 is unsure, go immediately to Support A (Guidance on figuring out study more first)
//  -> if for q4-8 at least one response is yes, but q2 is not yes, go to likely WMO, potentially non-WMO/VCWE (i.e. links to all three as well as support info)
//  -> if q2-8 all no, go to definitely VCWE
//  -> for q2,4-8 and none of answers are yes, if majority response is no, to likely VCWE page; if majority response is unsure or tied, to support page B
//  -> if q2 is yes and majority of others are no, go to likely non-WMO info (include reference to VCWE); if majority of others is unsure or tied, to support page B

    if (currentId === 'quest1') {
      // special logic:
      if (currentAnswer === 'no') {
        destination = 'defVCWEoutcome';
      } else if (currentAnswer === 'unsure') {
        destination = 'suppA';
      } // NB: quest2 does not need special logic because always advances to quest3
    } else if (currentId === 'quest3') {
      // special logic:
      if (currentAnswer === 'yes') {
        destination = 'defWMOoutcome';
      } else if (currentAnswer === 'unsure') {
        destination = 'suppA';
      }
    } else if (['quest4', 'quest5', 'quest6', 'quest7'].includes(currentId)) { // this is like the %in% operator in R
    // quest8 not included here because this is just for auto-navigation before end of quiz if quest2 and any of above are yes.
      // special logic:
      if (q2Answer === 'yes' && currentAnswer === 'yes') {
        destination = 'defWMOoutcome';
      }
    } else if (currentId === 'quest8') { //final special logic should only happen when current Id is at last question because need to look at all responses
      const counts = getTally(); // determine presence of yes answers/totals no's and unsures in questions 4-8

      // special logic:
      if (q2Answer !== 'yes' && counts.hasYes) {
          destination = 'possWMOoutcome';
        } else if (q2Answer === 'no' && counts.no === 5) {
          destination = 'defVCWEoutcome';
        } else if (q2Answer !== 'yes' && (counts.no > counts.unsure)) {
          destination = 'possVCWEoutcome';
        } else if (q2Answer === 'yes' && (counts.no > counts.unsure)) {
          destination = 'possNonWMOoutcome';
        } else {
          destination = 'suppB';
        }
    }

    // 2. Choose the action based on how the function was called
    if (isAutoAdvance) {
        // This is for the first time an answer is provided so that the next button can appear when needed
        handleQuizChange(currentId, destination, config.form);
    } else {
        // This is for the next buttons to function when there is no change to input
        nextDiv(currentId, destination);
    }
}




// question event listeners (auto advance on change)

q1.addEventListener('change', () => navigateQuiz('quest1'));
q2.addEventListener('change', () => navigateQuiz('quest2'));
q3.addEventListener('change', () => navigateQuiz('quest3'));
q4.addEventListener('change', () => navigateQuiz('quest4'));
q5.addEventListener('change', () => navigateQuiz('quest5'));
q6.addEventListener('change', () => navigateQuiz('quest6'));
q7.addEventListener('change', () => navigateQuiz('quest7'));
q8.addEventListener('change', () => navigateQuiz('quest8'));


//next buttons (specific routing, but without auto-advance)

btn1_2.addEventListener('click', () => navigateQuiz('quest1', isAutoAdvance = false));
btn2_3.addEventListener('click', () => navigateQuiz('quest2', isAutoAdvance = false));
btn3_4.addEventListener('click', () => navigateQuiz('quest3', isAutoAdvance = false));
btn4_5.addEventListener('click', () => navigateQuiz('quest4', isAutoAdvance = false));
btn5_6.addEventListener('click', () => navigateQuiz('quest5', isAutoAdvance = false));
btn6_7.addEventListener('click', () => navigateQuiz('quest6', isAutoAdvance = false));
btn7_8.addEventListener('click', () => navigateQuiz('quest7', isAutoAdvance = false));
btn8_end.addEventListener('click', () => navigateQuiz('quest8', isAutoAdvance = false));


// back (back buttons done with nextDiv directly because navigateQuiz goes forward (maybe later can add conditional for forward vs back))

btn2_1.addEventListener('click', (event) => {
      nextDiv('quest2','quest1')
  });

btn3_2.addEventListener('click', (event) => {
      nextDiv('quest3','quest2')
  });

btn4_3.addEventListener('click', (event) => {
      nextDiv('quest4','quest3')
  });

btn5_4.addEventListener('click', (event) => {
      nextDiv('quest5','quest4')
  });

btn6_5.addEventListener('click', (event) => {
      nextDiv('quest6','quest5')
  });

btn7_6.addEventListener('click', (event) => {
      nextDiv('quest7','quest6')
  });

btn8_7.addEventListener('click', (event) => {
      nextDiv('quest8','quest7')
  });

// nav buttons back from outcomes to last viewed quiz question

defWMOback.addEventListener('click', (event) => {
 const lastId = historyStack[historyStack.length - 2];

 nextDiv('defWMOoutcome', lastId);

});


defVCWEback.addEventListener('click', (event) => {
 const lastId = historyStack[historyStack.length - 2];

 nextDiv('defVCWEoutcome', lastId);

});



possWMOback.addEventListener('click', (event) => {
 const lastId = historyStack[historyStack.length - 2];

 nextDiv('possWMOoutcome', lastId);

});


possNonWMOback.addEventListener('click', (event) => {
 const lastId = historyStack[historyStack.length - 2];

 nextDiv('possNonWMOoutcome', lastId);

});


possVCWEback.addEventListener('click', (event) => {
 const lastId = historyStack[historyStack.length - 2];

 nextDiv('possVCWEoutcome', lastId);

});


suppAback.addEventListener('click', (event) => {
 const lastId = historyStack[historyStack.length - 2];

 nextDiv('suppA', lastId);

});

suppBback.addEventListener('click', (event) => {
 const lastId = historyStack[historyStack.length - 2];

 nextDiv('suppB', lastId);

});

// add event listeners to buttons that redirect to guidance sections once results of quiz given

intWMOguid.addEventListener('click', (event) => {
      nextDiv('defWMOoutcome','wmoGuidance', recordHistory = false) // don't record history now that leaving quiz
  });


</script>
